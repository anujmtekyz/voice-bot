# Cursor Rules for JIRA Voice Bot Project

This document outlines the coding standards, best practices, and rules to follow when developing the JIRA Voice Bot application.

## 1. Code Documentation

### 1.1 JSDoc Comments

- **Always include JSDoc comments** for classes, methods, and functions
- Document parameters, return types, and thrown exceptions
- Include a brief description of what the function/method does

Example:
```typescript
/**
 * Validates user credentials and generates authentication tokens
 * 
 * @param {LoginDto} loginDto - The login credentials (email and password)
 * @returns {Promise<AuthResponseDto>} Authentication tokens and user info
 * @throws {UnauthorizedException} When credentials are invalid or user is inactive
 */
async login(loginDto: LoginDto): Promise<AuthResponseDto> {
  // Implementation
}
```

### 1.2 Class Documentation

- Document the purpose of each class
- Include @class tag and description

Example:
```typescript
/**
 * @class AuthService
 * Handles authentication-related operations including login, registration, 
 * and token management
 */
@Injectable()
export class AuthService {
  // Implementation
}
```

## 2. Linting Rules

### 2.1 TypeScript Configuration

- Strict type checking enabled
- All properties must be initialized or marked as optional/nullable
- No implicit any types
- No unused local variables or parameters

### 2.2 SonarQube Quality Gates

- No code smells categorized as "Blocker" or "Critical"
- Maintain test coverage above 80%
- Duplicate code should be less than 5%
- Cognitive complexity should be kept low

### 2.3 Code Style

- Use camelCase for variables and methods
- Use PascalCase for classes, interfaces, and types
- Use kebab-case for file names
- Always use semicolons
- Use single quotes for strings
- Indent with 2 spaces
- Maximum line length: 100 characters

## 3. Code Quality and Complexity

### 3.1 Function/Method Complexity

- **Maximum method length**: 30 lines
- **Maximum cyclomatic complexity**: 10
- **Maximum nesting depth**: 3 levels

### 3.2 Class Size

- **Maximum class length**: 300 lines
- **Maximum methods per class**: 15
- **Maximum properties per class**: 10

### 3.3 Error Handling

- Always use typed exceptions
- Avoid using generic catch blocks; catch specific exceptions
- Log exceptions with appropriate context
- Use custom exceptions to provide meaningful error messages

Example:
```typescript
try {
  // Operation that might fail
} catch (error) {
  if (error instanceof TypeORMError) {
    throw new InternalServerErrorException('Database operation failed');
  }
  throw error;
}
```

## 4. Architecture and Reusability

### 4.1 Reusability

- Create shared utilities and services for common functionality
- Use inheritance and composition appropriately
- Extract reusable code into separate functions/methods
- Create generic base classes for shared behavior

### 4.2 Dependency Injection

- Use constructor injection for dependencies
- Keep components loosely coupled
- Use interfaces for dependency contracts
- Avoid the Service Locator pattern

Example:
```typescript
@Injectable()
export class AuthService {
  constructor(
    private readonly usersService: UsersService,
    private readonly jwtService: JwtService,
    private readonly configService: ConfigService,
  ) {}
}
```

### 4.3 Design Patterns

- Use the Repository pattern for database operations
- Use the Factory pattern for creating complex objects
- Use the Strategy pattern for interchangeable algorithms
- Use the Decorator pattern for extending functionality

## 5. Testing

### 5.1 Unit Tests

- Every service and controller must have unit tests
- Mock external dependencies
- Test both successful and failure scenarios
- Use descriptive test names

### 5.2 Integration Tests

- Test interactions between components
- Test database operations
- Test API endpoints
- Use separate test database

## 6. Security

### 6.1 Authentication and Authorization

- Use JWT for authentication
- Implement role-based access control
- Validate all input data
- Use HTTPS for all production endpoints

### 6.2 Data Protection

- Hash passwords using bcrypt
- Don't store sensitive information in logs
- Use environment variables for credentials
- Never return sensitive data in API responses

## 7. Performance

### 7.1 Database Access

- Use indexing for frequently queried fields
- Optimize queries to fetch only necessary data
- Use lazy loading for related entities
- Paginate large result sets

### 7.2 Caching

- Cache frequently accessed data
- Use appropriate TTL for cached items
- Invalidate cache when data changes
- Use Redis for distributed caching

## 8. Commit Rules

### 8.1 Commit Messages

- Use conventional commit format: `type(scope): message`
- Types: feat, fix, docs, style, refactor, test, chore
- Keep messages concise and descriptive
- Reference issue numbers when applicable

Example:
```
feat(auth): implement JWT refresh token functionality
fix(users): resolve issue with duplicate email validation
docs(readme): update installation instructions
```

### 8.2 Pull Requests

- Keep PRs focused on a single feature or fix
- Include tests for new functionality
- Ensure all CI checks pass
- Request code reviews from team members

## 9. API Design

### 9.1 REST Conventions

- Use plural nouns for resource endpoints (e.g., `/users` instead of `/user`)
- Use HTTP methods appropriately (GET, POST, PUT, DELETE)
- Return appropriate status codes
- Provide consistent error response format

### 9.2 DTO Validation

- Always validate incoming DTOs
- Use class-validator decorators
- Provide helpful validation error messages
- Transform data to the correct type with class-transformer 